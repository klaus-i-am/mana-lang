module main

// Force cache invalidation with updated example
fn divide(a: float, b: float) -> Result<float, str> {
    if b == 0.0 {
        return err("Division by zero")
    }
    return ok(a / b)
}

fn calculate() -> Result<float, str> {
    // 'or' operator for clean error propagation
    let x = divide(10.0, 2.0) or return err("First division failed")
    let y = divide(x, 2.0) or return err("Second division failed")
    return ok(y)
}

fn main() {
    // 'when' for Result pattern matching
    when calculate() {
        ok(result) -> println("Result: ", result)
        err(e) -> println("Error: ", e)
    }

    // 'or' with default value - use fallback on error
    let safe_result = divide(10.0, 0.0) or 0.0
    println("10 / 0 with fallback: ", safe_result)

    let good_result = divide(20.0, 4.0) or 0.0
    println("20 / 4 = ", good_result)
}
