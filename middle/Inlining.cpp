#include "Inlining.h"
#include "../frontend/AstDeclarations.h"
#include "../frontend/AstStatements.h"
#include "../frontend/AstExpressions.h"
#include <unordered_set>
#include <unordered_map>

using namespace mana::frontend;

namespace mana::middle {

    // Count statements in a block
    static int count_statements(const AstBlockStmt* block) {
        if (!block) return 0;
        int count = 0;
        for (const auto& stmt : block->statements) {
            count++;
            if (stmt->kind == NodeKind::BlockStmt) {
                count += count_statements(static_cast<const AstBlockStmt*>(stmt.get()));
            }
            else if (stmt->kind == NodeKind::IfStmt) {
                auto* if_stmt = static_cast<const AstIfStmt*>(stmt.get());
                if (if_stmt->then_block && if_stmt->then_block->kind == NodeKind::BlockStmt) {
                    count += count_statements(static_cast<const AstBlockStmt*>(if_stmt->then_block.get()));
                }
                if (if_stmt->else_block && if_stmt->else_block->kind == NodeKind::BlockStmt) {
                    count += count_statements(static_cast<const AstBlockStmt*>(if_stmt->else_block.get()));
                }
            }
        }
        return count;
    }

    // Simple check for recursive calls
    static bool contains_call(const AstStmt* s, const std::string& fn_name);

    static bool contains_call(const AstStmt* s, const std::string& fn_name) {
        if (!s) return false;
        switch (s->kind) {
        case NodeKind::BlockStmt: {
            auto* block = static_cast<const AstBlockStmt*>(s);
            for (const auto& stmt : block->statements) {
                if (contains_call(stmt.get(), fn_name)) return true;
            }
            break;
        }
        case NodeKind::ExprStmt: {
            auto* expr_stmt = static_cast<const AstExprStmt*>(s);
            if (expr_stmt->expr && expr_stmt->expr->kind == NodeKind::CallExpr) {
                auto* call = static_cast<const AstCallExpr*>(expr_stmt->expr.get());
                if (call->func_name == fn_name) return true;
            }
            break;
        }
        case NodeKind::ReturnStmt: {
            auto* ret = static_cast<const AstReturnStmt*>(s);
            if (ret->value && ret->value->kind == NodeKind::CallExpr) {
                auto* call = static_cast<const AstCallExpr*>(ret->value.get());
                if (call->func_name == fn_name) return true;
            }
            break;
        }
        case NodeKind::VarDeclStmt: {
            auto* var = static_cast<const AstVarDeclStmt*>(s);
            if (var->init_expr && var->init_expr->kind == NodeKind::CallExpr) {
                auto* call = static_cast<const AstCallExpr*>(var->init_expr.get());
                if (call->func_name == fn_name) return true;
            }
            break;
        }
        case NodeKind::IfStmt: {
            auto* if_stmt = static_cast<const AstIfStmt*>(s);
            if (contains_call(if_stmt->then_block.get(), fn_name)) return true;
            if (contains_call(if_stmt->else_block.get(), fn_name)) return true;
            break;
        }
        case NodeKind::WhileStmt: {
            auto* while_stmt = static_cast<const AstWhileStmt*>(s);
            if (contains_call(while_stmt->body.get(), fn_name)) return true;
            break;
        }
        default:
            break;
        }
        return false;
    }

    static bool is_recursive(const AstFuncDecl* fn) {
        if (!fn || !fn->body) return false;
        for (const auto& stmt : fn->body->statements) {
            if (contains_call(stmt.get(), fn->name)) return true;
        }
        return false;
    }

    void Inlining::run(AstModule* module) {
        if (!module) return;
        
        // Identify inline candidates based on simple heuristics
        // Since we emit C++, we rely on the C++ compiler for actual inlining
        // This pass just identifies functions that are good candidates
        
        for (auto& d : module->decls) {
            if (!d || d->kind != NodeKind::FunctionDecl) continue;
            auto* fn = static_cast<AstFuncDecl*>(d.get());
            
            // Skip functions without bodies (extern)
            if (!fn->body) continue;
            
            // Skip main function
            if (fn->name == "main") continue;
            
            // Skip test functions
            if (fn->is_test) continue;
            
            // Check statement count
            int stmt_count = count_statements(fn->body.get());
            if (stmt_count > MAX_INLINE_STATEMENTS) continue;
            
            // Skip recursive functions
            if (is_recursive(fn)) continue;
            
            // Note: The actual inlining hint is generated by CppEmitter
            // based on the function's characteristics
        }
    }

} // namespace mana::middle
