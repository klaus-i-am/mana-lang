// OpenGL Lighting Example
// Demonstrates math library with basic Phong lighting

fn main() {
    if !gl_init() {
        println("Failed to initialize GLFW");
        return;
    }

    gl_window_hint(GLFW_CONTEXT_VERSION_MAJOR(), 3);
    gl_window_hint(GLFW_CONTEXT_VERSION_MINOR(), 3);
    gl_window_hint(GLFW_OPENGL_PROFILE(), GLFW_OPENGL_CORE_PROFILE());

    let window = gl_create_window(1024, 768, "Mana - Lighting Demo");
    if window == 0 {
        println("Failed to create window");
        gl_terminate();
        return;
    }

    gl_make_context_current(window);
    if !gl_load_gl() {
        println("Failed to load OpenGL");
        gl_terminate();
        return;
    }

    gl_enable(GL_DEPTH_TEST());

    // Create shaders
    let object_shader = create_object_shader();
    let light_shader = create_light_shader();

    if object_shader == 0 || light_shader == 0 {
        gl_terminate();
        return;
    }

    // Create geometry
    let cube_vao = create_cube_with_normals();

    // Setup camera
    let camera_pos = math::vec3(3.0, 3.0, 6.0);
    let camera_target = math::vec3(0.0, 0.0, 0.0);
    let up = math::vec3(0.0, 1.0, 0.0);

    let view = math::look_at(camera_pos, camera_target, up);
    let projection = math::perspective(math::radians(45.0), 1024.0 / 768.0, 0.1, 100.0);

    // Light properties
    let light_color = math::vec3(1.0, 1.0, 1.0);
    let ambient_strength = 0.15;
    let specular_strength = 0.5;
    let shininess = 32.0;

    // Object color
    let object_color = math::vec3(1.0, 0.5, 0.31);  // Coral color

    println("Mana Lighting Demo");
    println("Press ESC to exit");

    let time = 0.0;

    while !gl_window_should_close(window) {
        if gl_get_key(window, GLFW_KEY_ESCAPE()) == GLFW_PRESS() {
            gl_set_window_should_close(window, true);
        }

        time = gl_get_time();

        // Animate light position (orbiting)
        let light_x = sin(time) * 3.0;
        let light_y = 2.0;
        let light_z = cos(time) * 3.0;
        let light_pos = math::vec3(light_x, light_y, light_z);

        // Clear
        gl_clear_color(0.05, 0.05, 0.08, 1.0);
        gl_clear(GL_COLOR_BUFFER_BIT() | GL_DEPTH_BUFFER_BIT());

        // Draw lit object
        gl_use_program(object_shader);

        // Set matrices
        let model = math::rotate_y(time * 0.3);
        gl_uniform_matrix4fv(gl_get_uniform_location(object_shader, "model"), model, false);
        gl_uniform_matrix4fv(gl_get_uniform_location(object_shader, "view"), view, false);
        gl_uniform_matrix4fv(gl_get_uniform_location(object_shader, "projection"), projection, false);

        // Set lighting uniforms
        gl_uniform_3f(gl_get_uniform_location(object_shader, "lightPos"), light_x, light_y, light_z);
        gl_uniform_3f(gl_get_uniform_location(object_shader, "viewPos"), 3.0, 3.0, 6.0);
        gl_uniform_3f(gl_get_uniform_location(object_shader, "lightColor"), 1.0, 1.0, 1.0);
        gl_uniform_3f(gl_get_uniform_location(object_shader, "objectColor"), 1.0, 0.5, 0.31);
        gl_uniform_1f(gl_get_uniform_location(object_shader, "ambientStrength"), ambient_strength);
        gl_uniform_1f(gl_get_uniform_location(object_shader, "specularStrength"), specular_strength);
        gl_uniform_1f(gl_get_uniform_location(object_shader, "shininess"), shininess);

        gl_bind_vertex_array(cube_vao);
        gl_draw_arrays(GL_TRIANGLES(), 0, 36);

        // Draw additional cubes
        // Green cube
        let model2 = math::translate(-2.5, 0.0, 0.0) * math::rotate_x(time * 0.5) * math::scale(0.7, 0.7, 0.7);
        gl_uniform_matrix4fv(gl_get_uniform_location(object_shader, "model"), model2, false);
        gl_uniform_3f(gl_get_uniform_location(object_shader, "objectColor"), 0.3, 0.8, 0.4);
        gl_draw_arrays(GL_TRIANGLES(), 0, 36);

        // Blue cube
        let model3 = math::translate(2.5, 0.0, 0.0) * math::rotate_z(time * 0.7) * math::scale(0.7, 0.7, 0.7);
        gl_uniform_matrix4fv(gl_get_uniform_location(object_shader, "model"), model3, false);
        gl_uniform_3f(gl_get_uniform_location(object_shader, "objectColor"), 0.3, 0.5, 0.9);
        gl_draw_arrays(GL_TRIANGLES(), 0, 36);

        // Draw light source (small white cube)
        gl_use_program(light_shader);
        let light_model = math::translate(light_x, light_y, light_z) * math::scale(0.2, 0.2, 0.2);
        gl_uniform_matrix4fv(gl_get_uniform_location(light_shader, "model"), light_model, false);
        gl_uniform_matrix4fv(gl_get_uniform_location(light_shader, "view"), view, false);
        gl_uniform_matrix4fv(gl_get_uniform_location(light_shader, "projection"), projection, false);

        gl_draw_arrays(GL_TRIANGLES(), 0, 36);

        gl_swap_buffers(window);
        gl_poll_events();
    }

    gl_delete_vertex_array(cube_vao);
    gl_delete_program(object_shader);
    gl_delete_program(light_shader);
    gl_terminate();
}

fn create_object_shader() -> u32 {
    let vert_src = "#version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;

out vec3 FragPos;
out vec3 Normal;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main() {
    FragPos = vec3(model * vec4(aPos, 1.0));
    Normal = mat3(transpose(inverse(model))) * aNormal;
    gl_Position = projection * view * vec4(FragPos, 1.0);
}";

    let frag_src = "#version 330 core
out vec4 FragColor;

in vec3 FragPos;
in vec3 Normal;

uniform vec3 lightPos;
uniform vec3 viewPos;
uniform vec3 lightColor;
uniform vec3 objectColor;
uniform float ambientStrength;
uniform float specularStrength;
uniform float shininess;

void main() {
    // Ambient
    vec3 ambient = ambientStrength * lightColor;

    // Diffuse
    vec3 norm = normalize(Normal);
    vec3 lightDir = normalize(lightPos - FragPos);
    float diff = max(dot(norm, lightDir), 0.0);
    vec3 diffuse = diff * lightColor;

    // Specular (Blinn-Phong)
    vec3 viewDir = normalize(viewPos - FragPos);
    vec3 halfwayDir = normalize(lightDir + viewDir);
    float spec = pow(max(dot(norm, halfwayDir), 0.0), shininess);
    vec3 specular = specularStrength * spec * lightColor;

    vec3 result = (ambient + diffuse + specular) * objectColor;
    FragColor = vec4(result, 1.0);
}";

    return compile_shader_program(vert_src, frag_src);
}

fn create_light_shader() -> u32 {
    let vert_src = "#version 330 core
layout (location = 0) in vec3 aPos;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main() {
    gl_Position = projection * view * model * vec4(aPos, 1.0);
}";

    let frag_src = "#version 330 core
out vec4 FragColor;

void main() {
    FragColor = vec4(1.0);
}";

    return compile_shader_program(vert_src, frag_src);
}

fn compile_shader_program(vert_src: string, frag_src: string) -> u32 {
    let vs = gl_create_shader(GL_VERTEX_SHADER());
    gl_shader_source(vs, vert_src);
    gl_compile_shader(vs);
    if !gl_get_shader_compile_status(vs) {
        println("Vertex shader error: " + gl_get_shader_info_log(vs));
        return 0;
    }

    let fs = gl_create_shader(GL_FRAGMENT_SHADER());
    gl_shader_source(fs, frag_src);
    gl_compile_shader(fs);
    if !gl_get_shader_compile_status(fs) {
        println("Fragment shader error: " + gl_get_shader_info_log(fs));
        return 0;
    }

    let prog = gl_create_program();
    gl_attach_shader(prog, vs);
    gl_attach_shader(prog, fs);
    gl_link_program(prog);
    if !gl_get_program_link_status(prog) {
        println("Link error: " + gl_get_program_info_log(prog));
        return 0;
    }

    gl_delete_shader(vs);
    gl_delete_shader(fs);
    return prog;
}

fn create_cube_with_normals() -> u32 {
    // Position (3) + Normal (3) per vertex
    let verts: Vec<f32> = [
        // Front face (normal: 0, 0, 1)
        -0.5, -0.5,  0.5,  0.0,  0.0,  1.0,
         0.5, -0.5,  0.5,  0.0,  0.0,  1.0,
         0.5,  0.5,  0.5,  0.0,  0.0,  1.0,
         0.5,  0.5,  0.5,  0.0,  0.0,  1.0,
        -0.5,  0.5,  0.5,  0.0,  0.0,  1.0,
        -0.5, -0.5,  0.5,  0.0,  0.0,  1.0,

        // Back face (normal: 0, 0, -1)
        -0.5, -0.5, -0.5,  0.0,  0.0, -1.0,
         0.5,  0.5, -0.5,  0.0,  0.0, -1.0,
         0.5, -0.5, -0.5,  0.0,  0.0, -1.0,
         0.5,  0.5, -0.5,  0.0,  0.0, -1.0,
        -0.5, -0.5, -0.5,  0.0,  0.0, -1.0,
        -0.5,  0.5, -0.5,  0.0,  0.0, -1.0,

        // Top face (normal: 0, 1, 0)
        -0.5,  0.5, -0.5,  0.0,  1.0,  0.0,
        -0.5,  0.5,  0.5,  0.0,  1.0,  0.0,
         0.5,  0.5,  0.5,  0.0,  1.0,  0.0,
         0.5,  0.5,  0.5,  0.0,  1.0,  0.0,
         0.5,  0.5, -0.5,  0.0,  1.0,  0.0,
        -0.5,  0.5, -0.5,  0.0,  1.0,  0.0,

        // Bottom face (normal: 0, -1, 0)
        -0.5, -0.5, -0.5,  0.0, -1.0,  0.0,
         0.5, -0.5,  0.5,  0.0, -1.0,  0.0,
        -0.5, -0.5,  0.5,  0.0, -1.0,  0.0,
         0.5, -0.5,  0.5,  0.0, -1.0,  0.0,
        -0.5, -0.5, -0.5,  0.0, -1.0,  0.0,
         0.5, -0.5, -0.5,  0.0, -1.0,  0.0,

        // Right face (normal: 1, 0, 0)
         0.5, -0.5, -0.5,  1.0,  0.0,  0.0,
         0.5,  0.5,  0.5,  1.0,  0.0,  0.0,
         0.5, -0.5,  0.5,  1.0,  0.0,  0.0,
         0.5,  0.5,  0.5,  1.0,  0.0,  0.0,
         0.5, -0.5, -0.5,  1.0,  0.0,  0.0,
         0.5,  0.5, -0.5,  1.0,  0.0,  0.0,

        // Left face (normal: -1, 0, 0)
        -0.5, -0.5, -0.5, -1.0,  0.0,  0.0,
        -0.5, -0.5,  0.5, -1.0,  0.0,  0.0,
        -0.5,  0.5,  0.5, -1.0,  0.0,  0.0,
        -0.5,  0.5,  0.5, -1.0,  0.0,  0.0,
        -0.5,  0.5, -0.5, -1.0,  0.0,  0.0,
        -0.5, -0.5, -0.5, -1.0,  0.0,  0.0
    ];

    let vao = gl_gen_vertex_array();
    let vbo = gl_gen_buffer();

    gl_bind_vertex_array(vao);
    gl_bind_buffer(GL_ARRAY_BUFFER(), vbo);
    gl_buffer_data_f32(GL_ARRAY_BUFFER(), verts, GL_STATIC_DRAW());

    // Position attribute
    gl_vertex_attrib_pointer(0, 3, 6, 0);
    gl_enable_vertex_attrib_array(0);

    // Normal attribute
    gl_vertex_attrib_pointer(1, 3, 6, 3);
    gl_enable_vertex_attrib_array(1);

    gl_bind_vertex_array(0);
    return vao;
}
