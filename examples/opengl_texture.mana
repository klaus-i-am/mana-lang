// OpenGL Texture Loading Example
// Demonstrates loading and rendering textures in Mana

fn main() {
    if !gl_init() {
        println("Failed to initialize GLFW");
        return;
    }

    gl_window_hint(GLFW_CONTEXT_VERSION_MAJOR(), 3);
    gl_window_hint(GLFW_CONTEXT_VERSION_MINOR(), 3);
    gl_window_hint(GLFW_OPENGL_PROFILE(), GLFW_OPENGL_CORE_PROFILE());

    let window = gl_create_window(800, 600, "Mana - Texture Demo");
    if window == 0 {
        println("Failed to create window");
        gl_terminate();
        return;
    }

    gl_make_context_current(window);

    if !gl_load_gl() {
        println("Failed to load OpenGL");
        gl_terminate();
        return;
    }

    // Enable blending for transparency
    gl_enable(GL_BLEND());
    gl_blend_func(GL_SRC_ALPHA(), GL_ONE_MINUS_SRC_ALPHA());

    // Create shader program for textured rendering
    let shader = create_texture_shader();
    if shader == 0 {
        gl_terminate();
        return;
    }

    // Create a textured quad
    let quad_vao = create_textured_quad();

    // Try to load a texture, fall back to checkerboard if file not found
    // Supported formats: BMP, TGA, PPM
    let texture = gl_load_texture_flipped("assets/texture.bmp");

    // If texture loading failed, create a checkerboard pattern
    if !texture.valid {
        println("Could not load texture.bmp, using checkerboard pattern");
        texture = gl_create_checkerboard_texture(64, 8);
    }

    // Get uniform locations
    gl_use_program(shader);
    let tex_loc = gl_get_uniform_location(shader, "uTexture");
    let model_loc = gl_get_uniform_location(shader, "model");
    let color_loc = gl_get_uniform_location(shader, "tintColor");

    // Set texture unit
    gl_uniform_1i(tex_loc, 0);

    println("Controls:");
    println("  1-4: Change tint color");
    println("  Space: Toggle rotation");
    println("  ESC: Quit");

    let rotation = 0.0;
    let rotating = true;
    let tint_r = 1.0;
    let tint_g = 1.0;
    let tint_b = 1.0;

    while !gl_window_should_close(window) {
        // Handle input
        if gl_get_key(window, GLFW_KEY_ESCAPE()) == GLFW_PRESS() {
            gl_set_window_should_close(window, true);
        }

        // Color selection (1-4 keys)
        if gl_get_key(window, 49) == GLFW_PRESS() {  // '1' key
            tint_r = 1.0; tint_g = 1.0; tint_b = 1.0;  // White
        }
        if gl_get_key(window, 50) == GLFW_PRESS() {  // '2' key
            tint_r = 1.0; tint_g = 0.5; tint_b = 0.5;  // Red tint
        }
        if gl_get_key(window, 51) == GLFW_PRESS() {  // '3' key
            tint_r = 0.5; tint_g = 1.0; tint_b = 0.5;  // Green tint
        }
        if gl_get_key(window, 52) == GLFW_PRESS() {  // '4' key
            tint_r = 0.5; tint_g = 0.5; tint_b = 1.0;  // Blue tint
        }

        // Update rotation
        if rotating {
            rotation = rotation + 0.01;
        }

        // Clear screen
        gl_clear_color(0.15, 0.15, 0.2, 1.0);
        gl_clear(GL_COLOR_BUFFER_BIT());

        // Draw textured quad
        gl_use_program(shader);

        // Bind texture to unit 0
        gl_bind_texture_unit(0, texture);

        // Set model matrix (rotation around Z axis)
        let model = math::rotate_z(rotation);
        gl_uniform_matrix4fv(model_loc, model, false);

        // Set tint color
        gl_uniform_3f(color_loc, tint_r, tint_g, tint_b);

        // Draw
        gl_bind_vertex_array(quad_vao);
        gl_draw_arrays(GL_TRIANGLES(), 0, 6);

        // Draw a second quad (smaller, different position and rotation)
        let model2 = math::translate(0.5, 0.3, 0.0) *
                     math::rotate_z(-rotation * 2.0) *
                     math::scale(0.3, 0.3, 1.0);
        gl_uniform_matrix4fv(model_loc, model2, false);
        gl_uniform_3f(color_loc, 1.0, 0.8, 0.2);  // Yellow tint
        gl_draw_arrays(GL_TRIANGLES(), 0, 6);

        // Draw a third quad
        let model3 = math::translate(-0.5, -0.3, 0.0) *
                     math::rotate_z(rotation * 1.5) *
                     math::scale(0.25, 0.25, 1.0);
        gl_uniform_matrix4fv(model_loc, model3, false);
        gl_uniform_3f(color_loc, 0.8, 0.2, 1.0);  // Purple tint
        gl_draw_arrays(GL_TRIANGLES(), 0, 6);

        gl_swap_buffers(window);
        gl_poll_events();
    }

    // Cleanup
    gl_delete_texture(texture);
    gl_delete_vertex_array(quad_vao);
    gl_delete_program(shader);
    gl_terminate();
}

fn create_texture_shader() -> u32 {
    let vert_src = "#version 330 core
layout (location = 0) in vec2 aPos;
layout (location = 1) in vec2 aTexCoord;

uniform mat4 model;

out vec2 TexCoord;

void main() {
    gl_Position = model * vec4(aPos, 0.0, 1.0);
    TexCoord = aTexCoord;
}";

    let frag_src = "#version 330 core
in vec2 TexCoord;
out vec4 FragColor;

uniform sampler2D uTexture;
uniform vec3 tintColor;

void main() {
    vec4 texColor = texture(uTexture, TexCoord);
    FragColor = vec4(texColor.rgb * tintColor, texColor.a);
}";

    let vs = gl_create_shader(GL_VERTEX_SHADER());
    gl_shader_source(vs, vert_src);
    gl_compile_shader(vs);
    if !gl_get_shader_compile_status(vs) {
        println("Vertex shader error: " + gl_get_shader_info_log(vs));
        return 0;
    }

    let fs = gl_create_shader(GL_FRAGMENT_SHADER());
    gl_shader_source(fs, frag_src);
    gl_compile_shader(fs);
    if !gl_get_shader_compile_status(fs) {
        println("Fragment shader error: " + gl_get_shader_info_log(fs));
        return 0;
    }

    let prog = gl_create_program();
    gl_attach_shader(prog, vs);
    gl_attach_shader(prog, fs);
    gl_link_program(prog);
    if !gl_get_program_link_status(prog) {
        println("Link error: " + gl_get_program_info_log(prog));
        return 0;
    }

    gl_delete_shader(vs);
    gl_delete_shader(fs);
    return prog;
}

fn create_textured_quad() -> u32 {
    // Position (2D) + TexCoord (2D)
    let vertices: Vec<f32> = [
        // First triangle
        -0.5, -0.5,   0.0, 0.0,  // bottom-left
         0.5, -0.5,   1.0, 0.0,  // bottom-right
         0.5,  0.5,   1.0, 1.0,  // top-right
        // Second triangle
         0.5,  0.5,   1.0, 1.0,  // top-right
        -0.5,  0.5,   0.0, 1.0,  // top-left
        -0.5, -0.5,   0.0, 0.0   // bottom-left
    ];

    let vao = gl_gen_vertex_array();
    let vbo = gl_gen_buffer();

    gl_bind_vertex_array(vao);
    gl_bind_buffer(GL_ARRAY_BUFFER(), vbo);
    gl_buffer_data_f32(GL_ARRAY_BUFFER(), vertices, GL_STATIC_DRAW());

    // Position attribute (location 0)
    gl_vertex_attrib_pointer(0, 2, 4, 0);
    gl_enable_vertex_attrib_array(0);

    // TexCoord attribute (location 1)
    gl_vertex_attrib_pointer(1, 2, 4, 2);
    gl_enable_vertex_attrib_array(1);

    gl_bind_vertex_array(0);
    return vao;
}
