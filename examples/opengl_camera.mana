// OpenGL FPS Camera Example
// Demonstrates math library with interactive 3D camera

fn main() {
    // Initialize GLFW
    if !gl_init() {
        println("Failed to initialize GLFW");
        return;
    }

    // Set OpenGL version hints (3.3 Core)
    gl_window_hint(GLFW_CONTEXT_VERSION_MAJOR(), 3);
    gl_window_hint(GLFW_CONTEXT_VERSION_MINOR(), 3);
    gl_window_hint(GLFW_OPENGL_PROFILE(), GLFW_OPENGL_CORE_PROFILE());

    // Create window
    let window = gl_create_window(1280, 720, "Mana - FPS Camera Demo");
    if window == 0 {
        println("Failed to create window");
        gl_terminate();
        return;
    }

    gl_make_context_current(window);

    if !gl_load_gl() {
        println("Failed to load OpenGL");
        gl_terminate();
        return;
    }

    // Enable depth testing
    gl_enable(GL_DEPTH_TEST());

    // Compile shaders
    let shader = create_shader();
    if shader == 0 {
        gl_terminate();
        return;
    }

    // Create geometry
    let cube_vao = create_cube();
    let grid_vao = create_grid();

    // Get uniform locations
    gl_use_program(shader);
    let model_loc = gl_get_uniform_location(shader, "model");
    let view_loc = gl_get_uniform_location(shader, "view");
    let proj_loc = gl_get_uniform_location(shader, "projection");
    let color_loc = gl_get_uniform_location(shader, "objectColor");

    // Camera state
    let cam_x = 0.0;
    let cam_y = 2.0;
    let cam_z = 8.0;
    let yaw = -90.0;  // Looking towards -Z
    let pitch = -15.0;

    // Projection matrix
    let aspect = 1280.0 / 720.0;
    let projection = math::perspective(math::radians(60.0), aspect, 0.1, 100.0);
    gl_uniform_matrix4fv(proj_loc, projection, false);

    // Timing
    let last_time = gl_get_time();
    let move_speed = 5.0;
    let look_speed = 50.0;

    println("Controls:");
    println("  W/S - Move forward/backward");
    println("  A/D - Strafe left/right");
    println("  Arrow keys - Look around");
    println("  Space - Move up");
    println("  ESC - Quit");

    // Main loop
    while !gl_window_should_close(window) {
        // Calculate delta time
        let current_time = gl_get_time();
        let dt = current_time - last_time;
        last_time = current_time;

        // Handle input
        if gl_get_key(window, GLFW_KEY_ESCAPE()) == GLFW_PRESS() {
            gl_set_window_should_close(window, true);
        }

        // Camera rotation (arrow keys)
        if gl_get_key(window, GLFW_KEY_LEFT()) == GLFW_PRESS() {
            yaw = yaw - look_speed * dt;
        }
        if gl_get_key(window, GLFW_KEY_RIGHT()) == GLFW_PRESS() {
            yaw = yaw + look_speed * dt;
        }
        if gl_get_key(window, GLFW_KEY_UP()) == GLFW_PRESS() {
            pitch = pitch + look_speed * dt;
            if pitch > 89.0 { pitch = 89.0; }
        }
        if gl_get_key(window, GLFW_KEY_DOWN()) == GLFW_PRESS() {
            pitch = pitch - look_speed * dt;
            if pitch < -89.0 { pitch = -89.0; }
        }

        // Calculate forward and right vectors from yaw
        let yaw_rad = math::radians(yaw);
        let forward_x = cos(yaw_rad);
        let forward_z = sin(yaw_rad);
        let right_x = -forward_z;
        let right_z = forward_x;

        // Camera movement (WASD)
        if gl_get_key(window, GLFW_KEY_W()) == GLFW_PRESS() {
            cam_x = cam_x + forward_x * move_speed * dt;
            cam_z = cam_z + forward_z * move_speed * dt;
        }
        if gl_get_key(window, GLFW_KEY_S()) == GLFW_PRESS() {
            cam_x = cam_x - forward_x * move_speed * dt;
            cam_z = cam_z - forward_z * move_speed * dt;
        }
        if gl_get_key(window, GLFW_KEY_A()) == GLFW_PRESS() {
            cam_x = cam_x - right_x * move_speed * dt;
            cam_z = cam_z - right_z * move_speed * dt;
        }
        if gl_get_key(window, GLFW_KEY_D()) == GLFW_PRESS() {
            cam_x = cam_x + right_x * move_speed * dt;
            cam_z = cam_z + right_z * move_speed * dt;
        }
        if gl_get_key(window, GLFW_KEY_SPACE()) == GLFW_PRESS() {
            cam_y = cam_y + move_speed * dt;
        }

        // Create view matrix using FPS view
        let cam_pos = math::vec3(cam_x, cam_y, cam_z);
        let view = math::fps_view(cam_pos, math::radians(yaw), math::radians(pitch));

        // Clear screen
        gl_clear_color(0.05, 0.05, 0.1, 1.0);
        gl_clear(GL_COLOR_BUFFER_BIT() | GL_DEPTH_BUFFER_BIT());

        gl_use_program(shader);
        gl_uniform_matrix4fv(view_loc, view, false);

        // Draw grid (floor)
        let grid_model = math::mat4_identity();
        gl_uniform_matrix4fv(model_loc, grid_model, false);
        gl_uniform_3f(color_loc, 0.3, 0.3, 0.3);
        gl_bind_vertex_array(grid_vao);
        gl_draw_arrays(GL_LINES(), 0, 84);

        // Draw multiple cubes at different positions
        gl_bind_vertex_array(cube_vao);

        // Center cube (red) - rotating
        let time = current_time;
        let center_model = math::translate(0.0, 0.5, 0.0) * math::rotate_y(time);
        gl_uniform_matrix4fv(model_loc, center_model, false);
        gl_uniform_3f(color_loc, 0.9, 0.2, 0.2);
        gl_draw_arrays(GL_TRIANGLES(), 0, 36);

        // Corner cubes (different colors)
        // Front-left (green)
        let fl_model = math::translate(-3.0, 0.5, 3.0) * math::rotate_y(time * 0.5);
        gl_uniform_matrix4fv(model_loc, fl_model, false);
        gl_uniform_3f(color_loc, 0.2, 0.9, 0.2);
        gl_draw_arrays(GL_TRIANGLES(), 0, 36);

        // Front-right (blue)
        let fr_model = math::translate(3.0, 0.5, 3.0) * math::rotate_x(time * 0.7);
        gl_uniform_matrix4fv(model_loc, fr_model, false);
        gl_uniform_3f(color_loc, 0.2, 0.2, 0.9);
        gl_draw_arrays(GL_TRIANGLES(), 0, 36);

        // Back-left (yellow)
        let bl_model = math::translate(-3.0, 0.5, -3.0) * math::scale(0.8, 0.8, 0.8) * math::rotate_z(time * 0.3);
        gl_uniform_matrix4fv(model_loc, bl_model, false);
        gl_uniform_3f(color_loc, 0.9, 0.9, 0.2);
        gl_draw_arrays(GL_TRIANGLES(), 0, 36);

        // Back-right (magenta)
        let br_model = math::translate(3.0, 0.5, -3.0) * math::scale(1.2, 1.2, 1.2);
        gl_uniform_matrix4fv(model_loc, br_model, false);
        gl_uniform_3f(color_loc, 0.9, 0.2, 0.9);
        gl_draw_arrays(GL_TRIANGLES(), 0, 36);

        // Floating cube (cyan) - bouncing
        let bounce_y = 2.0 + sin(time * 2.0) * 0.5;
        let float_model = math::translate(0.0, bounce_y, -5.0) * math::rotate_y(time * 2.0) * math::rotate_x(time);
        gl_uniform_matrix4fv(model_loc, float_model, false);
        gl_uniform_3f(color_loc, 0.2, 0.9, 0.9);
        gl_draw_arrays(GL_TRIANGLES(), 0, 36);

        gl_swap_buffers(window);
        gl_poll_events();
    }

    // Cleanup
    gl_delete_vertex_array(cube_vao);
    gl_delete_vertex_array(grid_vao);
    gl_delete_program(shader);
    gl_terminate();
}

fn create_shader() -> u32 {
    let vert_src = "#version 330 core
layout (location = 0) in vec3 aPos;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main() {
    gl_Position = projection * view * model * vec4(aPos, 1.0);
}";

    let frag_src = "#version 330 core
uniform vec3 objectColor;
out vec4 FragColor;

void main() {
    FragColor = vec4(objectColor, 1.0);
}";

    let vs = gl_create_shader(GL_VERTEX_SHADER());
    gl_shader_source(vs, vert_src);
    gl_compile_shader(vs);
    if !gl_get_shader_compile_status(vs) {
        println("Vertex shader error: " + gl_get_shader_info_log(vs));
        return 0;
    }

    let fs = gl_create_shader(GL_FRAGMENT_SHADER());
    gl_shader_source(fs, frag_src);
    gl_compile_shader(fs);
    if !gl_get_shader_compile_status(fs) {
        println("Fragment shader error: " + gl_get_shader_info_log(fs));
        return 0;
    }

    let prog = gl_create_program();
    gl_attach_shader(prog, vs);
    gl_attach_shader(prog, fs);
    gl_link_program(prog);
    if !gl_get_program_link_status(prog) {
        println("Link error: " + gl_get_program_info_log(prog));
        return 0;
    }

    gl_delete_shader(vs);
    gl_delete_shader(fs);
    return prog;
}

fn create_cube() -> u32 {
    let verts: Vec<f32> = [
        // Front
        -0.5, -0.5,  0.5,   0.5, -0.5,  0.5,   0.5,  0.5,  0.5,
         0.5,  0.5,  0.5,  -0.5,  0.5,  0.5,  -0.5, -0.5,  0.5,
        // Back
        -0.5, -0.5, -0.5,   0.5,  0.5, -0.5,   0.5, -0.5, -0.5,
         0.5,  0.5, -0.5,  -0.5, -0.5, -0.5,  -0.5,  0.5, -0.5,
        // Top
        -0.5,  0.5, -0.5,  -0.5,  0.5,  0.5,   0.5,  0.5,  0.5,
         0.5,  0.5,  0.5,   0.5,  0.5, -0.5,  -0.5,  0.5, -0.5,
        // Bottom
        -0.5, -0.5, -0.5,   0.5, -0.5,  0.5,  -0.5, -0.5,  0.5,
         0.5, -0.5,  0.5,  -0.5, -0.5, -0.5,   0.5, -0.5, -0.5,
        // Right
         0.5, -0.5, -0.5,   0.5,  0.5,  0.5,   0.5, -0.5,  0.5,
         0.5,  0.5,  0.5,   0.5, -0.5, -0.5,   0.5,  0.5, -0.5,
        // Left
        -0.5, -0.5, -0.5,  -0.5, -0.5,  0.5,  -0.5,  0.5,  0.5,
        -0.5,  0.5,  0.5,  -0.5,  0.5, -0.5,  -0.5, -0.5, -0.5
    ];

    let vao = gl_gen_vertex_array();
    let vbo = gl_gen_buffer();

    gl_bind_vertex_array(vao);
    gl_bind_buffer(GL_ARRAY_BUFFER(), vbo);
    gl_buffer_data_f32(GL_ARRAY_BUFFER(), verts, GL_STATIC_DRAW());

    gl_vertex_attrib_pointer(0, 3, 3, 0);
    gl_enable_vertex_attrib_array(0);

    gl_bind_vertex_array(0);
    return vao;
}

fn create_grid() -> u32 {
    // Create a grid on the XZ plane
    let lines: Vec<f32> = [];
    let size = 10.0;
    let step = 1.0;

    // Lines along X axis
    let z = -size;
    while z <= size {
        lines.push(-size); lines.push(0.0); lines.push(z);
        lines.push(size);  lines.push(0.0); lines.push(z);
        z = z + step;
    }

    // Lines along Z axis
    let x = -size;
    while x <= size {
        lines.push(x); lines.push(0.0); lines.push(-size);
        lines.push(x); lines.push(0.0); lines.push(size);
        x = x + step;
    }

    let vao = gl_gen_vertex_array();
    let vbo = gl_gen_buffer();

    gl_bind_vertex_array(vao);
    gl_bind_buffer(GL_ARRAY_BUFFER(), vbo);
    gl_buffer_data_f32(GL_ARRAY_BUFFER(), lines, GL_STATIC_DRAW());

    gl_vertex_attrib_pointer(0, 3, 3, 0);
    gl_enable_vertex_attrib_array(0);

    gl_bind_vertex_array(0);
    return vao;
}
