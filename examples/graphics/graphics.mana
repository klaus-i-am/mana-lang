module graphics

// ============================================================================
// Mana Graphics Library - All the boilerplate hidden here
// ============================================================================

// ----- GLFW FFI (pub for now due to visibility bug) -----
pub extern fn mana_glfwInit() -> i32
pub extern fn mana_glfwTerminate() -> void
pub extern fn mana_glfwCreateWindow(width: i32, height: i32, title: string, monitor: i64, share: i64) -> i64
pub extern fn mana_glfwDestroyWindow(window: i64) -> void
pub extern fn mana_glfwMakeContextCurrent(window: i64) -> void
pub extern fn mana_glfwWindowShouldClose(window: i64) -> i32
pub extern fn mana_glfwSwapBuffers(window: i64) -> void
pub extern fn mana_glfwPollEvents() -> void
pub extern fn mana_glfwSwapInterval(interval: i32) -> void
pub extern fn mana_glfwGetTime() -> f64
pub extern fn mana_gladLoadGL() -> i32

// ----- OpenGL FFI -----
pub extern fn mana_glClearColor(r: f32, g: f32, b: f32, a: f32) -> void
pub extern fn mana_glClear(mask: i32) -> void
pub extern fn mana_glViewport(x: i32, y: i32, width: i32, height: i32) -> void
pub extern fn mana_glCreateShader(shader_type: i32) -> i32
pub extern fn mana_glShaderSource(shader: i32, source: string) -> void
pub extern fn mana_glCompileShader(shader: i32) -> void
pub extern fn mana_glGetShaderiv(shader: i32, pname: i32) -> i32
pub extern fn mana_glGetShaderInfoLog(shader: i32) -> void
pub extern fn mana_glDeleteShader(shader: i32) -> void
pub extern fn mana_glCreateProgram() -> i32
pub extern fn mana_glAttachShader(program: i32, shader: i32) -> void
pub extern fn mana_glLinkProgram(program: i32) -> void
pub extern fn mana_glGetProgramiv(program: i32, pname: i32) -> i32
pub extern fn mana_glGetProgramInfoLog(program: i32) -> void
pub extern fn mana_glUseProgram(program: i32) -> void
pub extern fn mana_glDeleteProgram(program: i32) -> void
pub extern fn mana_glGenVertexArray() -> i32
pub extern fn mana_glBindVertexArray(vao: i32) -> void
pub extern fn mana_glDeleteVertexArray(vao: i32) -> void
pub extern fn mana_glDeleteBuffer(buffer: i32) -> void
pub extern fn mana_glDrawArrays(mode: i32, first: i32, count: i32) -> void
pub extern fn mana_glGetUniformLocation(program: i32, name: string) -> i32
pub extern fn mana_glUniform1f(location: i32, v: f32) -> void
pub extern fn mana_glUniform3f(location: i32, x: f32, y: f32, z: f32) -> void

// ----- OpenGL Constants -----
pub extern fn mana_GL_VERTEX_SHADER() -> i32
pub extern fn mana_GL_FRAGMENT_SHADER() -> i32
pub extern fn mana_GL_COMPILE_STATUS() -> i32
pub extern fn mana_GL_LINK_STATUS() -> i32
pub extern fn mana_GL_TRIANGLES() -> i32
pub extern fn mana_GL_COLOR_BUFFER_BIT() -> i32

// ----- Helpers -----
pub extern fn mana_createTriangleVBO() -> i32
pub extern fn mana_setupTriangleAttributes() -> void

// ============================================================================
// High-Level API - This is what users actually call
// ============================================================================

pub fn create_window(title: string, width: i32, height: i32) -> i64 {
    if mana_glfwInit() == 0 {
        println("Failed to initialize GLFW")
        return 0
    }
    let window: i64 = mana_glfwCreateWindow(width, height, title, 0, 0)
    if window == 0 {
        println("Failed to create window")
        mana_glfwTerminate()
        return 0
    }
    mana_glfwMakeContextCurrent(window)
    if mana_gladLoadGL() == 0 {
        println("Failed to load OpenGL")
        mana_glfwDestroyWindow(window)
        mana_glfwTerminate()
        return 0
    }
    mana_glfwSwapInterval(1)
    mana_glViewport(0, 0, width, height)
    return window
}

pub fn window_open(window: i64) -> bool {
    return mana_glfwWindowShouldClose(window) == 0
}

pub fn clear(r: f32, g: f32, b: f32) -> void {
    mana_glClearColor(r, g, b, 1.0)
    mana_glClear(mana_GL_COLOR_BUFFER_BIT())
}

pub fn present(window: i64) -> void {
    mana_glfwSwapBuffers(window)
    mana_glfwPollEvents()
}

pub fn close_window(window: i64) -> void {
    mana_glfwDestroyWindow(window)
    mana_glfwTerminate()
}

pub fn get_time() -> f64 {
    return mana_glfwGetTime()
}

pub fn create_shader(vertex_src: string, fragment_src: string) -> i32 {
    let vs: i32 = mana_glCreateShader(mana_GL_VERTEX_SHADER())
    mana_glShaderSource(vs, vertex_src)
    mana_glCompileShader(vs)
    if mana_glGetShaderiv(vs, mana_GL_COMPILE_STATUS()) == 0 {
        mana_glGetShaderInfoLog(vs)
        return 0
    }

    let fs: i32 = mana_glCreateShader(mana_GL_FRAGMENT_SHADER())
    mana_glShaderSource(fs, fragment_src)
    mana_glCompileShader(fs)
    if mana_glGetShaderiv(fs, mana_GL_COMPILE_STATUS()) == 0 {
        mana_glGetShaderInfoLog(fs)
        return 0
    }

    let program: i32 = mana_glCreateProgram()
    mana_glAttachShader(program, vs)
    mana_glAttachShader(program, fs)
    mana_glLinkProgram(program)
    mana_glDeleteShader(vs)
    mana_glDeleteShader(fs)
    return program
}

pub fn use_shader(program: i32) -> void {
    mana_glUseProgram(program)
}

pub fn create_triangle() -> i32 {
    let vao: i32 = mana_glGenVertexArray()
    mana_glBindVertexArray(vao)
    mana_createTriangleVBO()
    mana_setupTriangleAttributes()
    return vao
}

pub fn draw_triangle(vao: i32) -> void {
    mana_glBindVertexArray(vao)
    mana_glDrawArrays(mana_GL_TRIANGLES(), 0, 3)
}
