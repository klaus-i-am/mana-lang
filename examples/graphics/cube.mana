module cube

import "graphics"

// Additional 3D FFI (not yet in graphics.mana)
extern fn mana_glEnable(cap: i32) -> void
extern fn mana_GL_DEPTH_TEST() -> i32
extern fn mana_GL_DEPTH_BUFFER_BIT() -> i32
extern fn mana_glUniformMatrix4fv(location: i32, matrixPtr: i64) -> void
extern fn mana_setPerspective(fovDegrees: f32, aspect: f32, nearZ: f32, farZ: f32) -> void
extern fn mana_setCamera(eyeX: f32, eyeY: f32, eyeZ: f32) -> void
extern fn mana_setRotation(rx: f32, ry: f32, rz: f32) -> void
extern fn mana_getMVP() -> i64
extern fn mana_createCubeVBO() -> i32
extern fn mana_setupCubeAttributes() -> void
extern fn mana_drawCube() -> void

// Input FFI
extern fn mana_glfwGetKey(window: i64, key: i32) -> i32
extern fn mana_GLFW_KEY_W() -> i32
extern fn mana_GLFW_KEY_A() -> i32
extern fn mana_GLFW_KEY_S() -> i32
extern fn mana_GLFW_KEY_D() -> i32
extern fn mana_GLFW_KEY_Q() -> i32
extern fn mana_GLFW_KEY_E() -> i32
extern fn mana_GLFW_KEY_ESCAPE() -> i32
extern fn mana_GLFW_KEY_UP() -> i32
extern fn mana_GLFW_KEY_DOWN() -> i32
extern fn mana_GLFW_KEY_LEFT() -> i32
extern fn mana_GLFW_KEY_RIGHT() -> i32
extern fn mana_GLFW_KEY_SPACE() -> i32
extern fn mana_GLFW_PRESS() -> i32

fn key_pressed(window: i64, key: i32) -> bool {
    return mana_glfwGetKey(window, key) == mana_GLFW_PRESS()
}

fn clear_3d(r: f32, g: f32, b: f32) -> void {
    mana_glClearColor(r, g, b, 1.0)
    mana_glClear(mana_GL_COLOR_BUFFER_BIT() + mana_GL_DEPTH_BUFFER_BIT())
}

fn create_cube() -> i32 {
    let vao: i32 = mana_glGenVertexArray()
    mana_glBindVertexArray(vao)
    mana_createCubeVBO()
    mana_setupCubeAttributes()
    return vao
}

fn draw_cube(vao: i32) -> void {
    mana_glBindVertexArray(vao)
    mana_drawCube()
}

fn main() -> i32 {
    let window = create_window("Mana Cube - Arrow keys rotate, WASD move, ESC quit", 800, 600)
    if window == 0 { return 1 }

    // 3D shader with MVP matrix
    let vs = "#version 330 core\nlayout (location = 0) in vec3 aPos;\nlayout (location = 1) in vec3 aColor;\nuniform mat4 uMVP;\nout vec3 vertexColor;\nvoid main() { gl_Position = uMVP * vec4(aPos, 1.0); vertexColor = aColor; }"
    let fs = "#version 330 core\nin vec3 vertexColor;\nout vec4 FragColor;\nvoid main() { FragColor = vec4(vertexColor, 1.0); }"

    let shader = create_shader(vs, fs)
    let mvpLoc = mana_glGetUniformLocation(shader, "uMVP")
    let cube = create_cube()

    // Enable depth testing for 3D
    mana_glEnable(mana_GL_DEPTH_TEST())

    // Setup 3D projection
    mana_setPerspective(45.0, 1.333, 0.1, 100.0)

    // Rotation angles (controlled by arrow keys)
    let rx: f32 = 0.0
    let ry: f32 = 0.0
    let rz: f32 = 0.0

    // Camera position (controlled by WASD)
    let camX: f32 = 0.0
    let camY: f32 = 0.0
    let camZ: f32 = 3.0

    let speed: f32 = 0.05

    while window_open(window) {
        // ESC to quit
        if key_pressed(window, mana_GLFW_KEY_ESCAPE()) {
            break
        }

        // Arrow keys rotate
        if key_pressed(window, mana_GLFW_KEY_UP()) {
            rx = rx - speed
        }
        if key_pressed(window, mana_GLFW_KEY_DOWN()) {
            rx = rx + speed
        }
        if key_pressed(window, mana_GLFW_KEY_LEFT()) {
            ry = ry - speed
        }
        if key_pressed(window, mana_GLFW_KEY_RIGHT()) {
            ry = ry + speed
        }

        // Q/E roll
        if key_pressed(window, mana_GLFW_KEY_Q()) {
            rz = rz - speed
        }
        if key_pressed(window, mana_GLFW_KEY_E()) {
            rz = rz + speed
        }

        // WASD move camera
        if key_pressed(window, mana_GLFW_KEY_W()) {
            camZ = camZ - speed
        }
        if key_pressed(window, mana_GLFW_KEY_S()) {
            camZ = camZ + speed
        }
        if key_pressed(window, mana_GLFW_KEY_A()) {
            camX = camX - speed
        }
        if key_pressed(window, mana_GLFW_KEY_D()) {
            camX = camX + speed
        }

        // Space to reset
        if key_pressed(window, mana_GLFW_KEY_SPACE()) {
            rx = 0.0
            ry = 0.0
            rz = 0.0
            camX = 0.0
            camY = 0.0
            camZ = 3.0
        }

        // Update camera and rotation
        mana_setCamera(camX, camY, camZ)
        mana_setRotation(rx, ry, rz)

        // Render
        clear_3d(0.1, 0.1, 0.15)
        use_shader(shader)
        mana_glUniformMatrix4fv(mvpLoc, mana_getMVP())
        draw_cube(cube)

        present(window)
    }

    close_window(window)
    return 0
}
