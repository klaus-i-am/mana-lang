// LearnOpenGL Hello Triangle in Mana
// https://learnopengl.com/Getting-started/Hello-Triangle
//
// To compile the generated C++:
//   g++ -DMANA_OPENGL_ENABLED generated.cpp -o triangle -lglfw -lGL -ldl
// Or on Windows with MSVC:
//   cl /DMANA_OPENGL_ENABLED generated.cpp glfw3.lib opengl32.lib

fn vertex_shader_source() -> string {
    "#version 330 core
layout (location = 0) in vec3 aPos;
void main() {
    gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);
}"
}

fn fragment_shader_source() -> string {
    "#version 330 core
out vec4 FragColor;
void main() {
    FragColor = vec4(1.0, 0.5, 0.2, 1.0);
}"
}

fn compile_shader(shader_type: u32, source: string) -> u32 {
    let shader: u32 = gl_create_shader(shader_type);
    gl_shader_source(shader, source);
    gl_compile_shader(shader);

    if !gl_get_shader_compile_status(shader) {
        let log: string = gl_get_shader_info_log(shader);
        println(f"Shader compile error: {log}");
    }

    shader
}

fn create_shader_program() -> u32 {
    let vertex_shader: u32 = compile_shader(GL_VERTEX_SHADER(), vertex_shader_source());
    let fragment_shader: u32 = compile_shader(GL_FRAGMENT_SHADER(), fragment_shader_source());

    let program: u32 = gl_create_program();
    gl_attach_shader(program, vertex_shader);
    gl_attach_shader(program, fragment_shader);
    gl_link_program(program);

    if !gl_get_program_link_status(program) {
        let log: string = gl_get_program_info_log(program);
        println(f"Program link error: {log}");
    }

    gl_delete_shader(vertex_shader);
    gl_delete_shader(fragment_shader);

    program
}

fn main() -> i32 {
    // Initialize GLFW
    if !gl_init() {
        println("Failed to initialize GLFW");
        return -1;
    }

    // Configure GLFW for OpenGL 3.3 Core Profile
    gl_window_hint(GLFW_CONTEXT_VERSION_MAJOR(), 3);
    gl_window_hint(GLFW_CONTEXT_VERSION_MINOR(), 3);
    gl_window_hint(GLFW_OPENGL_PROFILE(), GLFW_OPENGL_CORE_PROFILE());

    // Create window
    let window = gl_create_window(800, 600, "Mana OpenGL Triangle");
    gl_make_context_current(window);

    // Load OpenGL function pointers
    if !gl_load_gl() {
        println("Failed to load OpenGL");
        return -1;
    }

    gl_viewport(0, 0, 800, 600);

    // Create shader program
    let shader_program: u32 = create_shader_program();

    // Triangle vertices (x, y, z)
    let vertices: Vec<f32> = [
        -0.5, -0.5, 0.0,
         0.5, -0.5, 0.0,
         0.0,  0.5, 0.0
    ];

    // Create VAO and VBO
    let vao: u32 = gl_gen_vertex_array();
    let vbo: u32 = gl_gen_buffer();

    // Bind VAO first
    gl_bind_vertex_array(vao);

    // Bind and set VBO
    gl_bind_buffer(GL_ARRAY_BUFFER(), vbo);
    gl_buffer_data_f32(GL_ARRAY_BUFFER(), vertices, GL_STATIC_DRAW());

    // Configure vertex attribute (location 0, 3 floats, stride 3, offset 0)
    gl_vertex_attrib_pointer(0, 3, 3, 0);
    gl_enable_vertex_attrib_array(0);

    // Unbind
    gl_bind_buffer(GL_ARRAY_BUFFER(), 0);
    gl_bind_vertex_array(0);

    println("Starting render loop... Press ESC to exit.");

    // Render loop
    while !gl_window_should_close(window) {
        // Input handling
        if gl_get_key(window, GLFW_KEY_ESCAPE()) == GLFW_PRESS() {
            gl_set_window_should_close(window, true);
        }

        // Clear screen with teal color
        gl_clear_color(0.2, 0.3, 0.3, 1.0);
        gl_clear(GL_COLOR_BUFFER_BIT());

        // Draw triangle
        gl_use_program(shader_program);
        gl_bind_vertex_array(vao);
        gl_draw_arrays(GL_TRIANGLES(), 0, 3);

        // Swap buffers and poll events
        gl_swap_buffers(window);
        gl_poll_events();
    }

    // Cleanup
    gl_delete_vertex_array(vao);
    gl_delete_buffer(vbo);
    gl_delete_program(shader_program);
    gl_terminate();

    println("Done!");
    0
}
